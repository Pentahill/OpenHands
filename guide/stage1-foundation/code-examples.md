# Agent-Action-Observation ä»£ç ç¤ºä¾‹è¯¦è§£

## ğŸ¯ æ¦‚è¿°

æœ¬æ–‡æ¡£æä¾›äº†OpenHandsé¡¹ç›®ä¸­Agent-Action-Observationæ¨¡å¼çš„è¯¦ç»†ä»£ç ç¤ºä¾‹ï¼Œå¸®åŠ©å¼€å‘è€…ç†è§£å…·ä½“çš„å®ç°ç»†èŠ‚å’Œæœ€ä½³å®è·µã€‚

## ğŸ“ å®Œæ•´çš„AAOå¾ªç¯ç¤ºä¾‹

### ç¤ºä¾‹1ï¼šå‘½ä»¤æ‰§è¡Œçš„å®Œæ•´æµç¨‹

```python
# ===== 1. Agentå†³ç­–é˜¶æ®µ =====
# æ–‡ä»¶ï¼šopenhands/agenthub/codeact_agent/codeact_agent.py

from openhands.controller.agent import Agent
from openhands.events.action import CmdRunAction
from openhands.core.schema import AgentState

class CodeActAgent(Agent):
    """ä»£ç æ‰§è¡Œä¸“ç”¨Agent"""
    
    async def step(self, state: State) -> Action:
        """Agentçš„æ ¸å¿ƒå†³ç­–æ–¹æ³•"""
        
        # 1. è·å–å½“å‰å¯¹è¯å†å²
        messages = self._get_messages(state)
        
        # 2. è°ƒç”¨LLMè¿›è¡Œæ¨ç†
        response = await self.llm.acompletion(
            messages=messages,
            temperature=0.1,
            max_tokens=1000
        )
        
        # 3. è§£æLLMå“åº”ï¼Œæå–Action
        action = self._parse_response(response)
        
        # 4. æ·»åŠ æ€è€ƒè¿‡ç¨‹
        if hasattr(action, 'thought'):
            action.thought = self._extract_thought(response)
        
        return action
    
    def _parse_response(self, response: str) -> Action:
        """è§£æLLMå“åº”ï¼Œåˆ›å»ºç›¸åº”çš„Action"""
        
        # æ£€æŸ¥æ˜¯å¦åŒ…å«å‘½ä»¤æ‰§è¡Œè¯·æ±‚
        if '<execute_bash>' in response:
            command = self._extract_bash_command(response)
            return CmdRunAction(
                command=command,
                thought=self._extract_thought(response)
            )
        
        # æ£€æŸ¥æ˜¯å¦åŒ…å«Pythonä»£ç æ‰§è¡Œ
        elif '<execute_ipython>' in response:
            code = self._extract_python_code(response)
            return IPythonRunCellAction(
                code=code,
                thought=self._extract_thought(response)
            )
        
        # é»˜è®¤è¿”å›æ¶ˆæ¯Action
        return MessageAction(content=response)
    
    def _extract_bash_command(self, response: str) -> str:
        """ä»å“åº”ä¸­æå–bashå‘½ä»¤"""
        import re
        pattern = r'<execute_bash>\s*(.*?)\s*</execute_bash>'
        match = re.search(pattern, response, re.DOTALL)
        return match.group(1).strip() if match else ""


# ===== 2. Actionå®šä¹‰å’Œå¤„ç† =====
# æ–‡ä»¶ï¼šopenhands/events/action/commands.py

from dataclasses import dataclass
from typing import ClassVar
from openhands.events.action.action import Action

@dataclass
class CmdRunAction(Action):
    """å‘½ä»¤æ‰§è¡ŒAction"""
    
    command: str  # è¦æ‰§è¡Œçš„å‘½ä»¤
    is_input: bool = False  # æ˜¯å¦ä¸ºè¾“å…¥åˆ°è¿è¡Œä¸­çš„è¿›ç¨‹
    thought: str = ''  # Agentçš„æ€è€ƒè¿‡ç¨‹
    blocking: bool = False  # æ˜¯å¦é˜»å¡æ‰§è¡Œ
    cwd: str | None = None  # å·¥ä½œç›®å½•
    hidden: bool = False  # æ˜¯å¦éšè—è¾“å‡º
    
    # ç±»å±æ€§
    action: str = "run"
    runnable: ClassVar[bool] = True
    
    @property
    def message(self) -> str:
        """Actionçš„æè¿°ä¿¡æ¯"""
        return f'Running command: {self.command}'
    
    def __str__(self) -> str:
        """Actionçš„å­—ç¬¦ä¸²è¡¨ç¤º"""
        ret = f'**CmdRunAction (source={self.source})**\n'
        if self.thought:
            ret += f'THOUGHT: {self.thought}\n'
        ret += f'COMMAND:\n{self.command}'
        return ret
    
    def validate(self) -> bool:
        """éªŒè¯Actionçš„æœ‰æ•ˆæ€§"""
        if not self.command or not self.command.strip():
            return False
        
        # æ£€æŸ¥å±é™©å‘½ä»¤
        dangerous_commands = ['rm -rf /', 'format', 'del /f /s /q']
        for dangerous in dangerous_commands:
            if dangerous in self.command.lower():
                return False
        
        return True


# ===== 3. æ§åˆ¶å™¨å¤„ç†é€»è¾‘ =====
# æ–‡ä»¶ï¼šopenhands/controller/agent_controller.py

class AgentController:
    """Agentæ§åˆ¶å™¨ï¼Œè´Ÿè´£åè°ƒAgentã€Runtimeå’Œäº‹ä»¶æµ"""
    
    def __init__(self, agent: Agent, runtime: Runtime, event_stream: EventStream):
        self.agent = agent
        self.runtime = runtime
        self.event_stream = event_stream
        self.state = State()
    
    async def step(self) -> None:
        """æ‰§è¡Œä¸€ä¸ªå®Œæ•´çš„AAOå¾ªç¯"""
        
        try:
            # 1. Agentå†³ç­–é˜¶æ®µ
            action = await self.agent.step(self.state)
            
            # 2. éªŒè¯Action
            if not self._validate_action(action):
                error_obs = ErrorObservation(
                    content="Invalid action generated by agent"
                )
                await self.event_stream.add_event(error_obs, EventSource.ENVIRONMENT)
                return
            
            # 3. è®°å½•Actionåˆ°äº‹ä»¶æµ
            await self.event_stream.add_event(action, EventSource.AGENT)
            
            # 4. æ‰§è¡ŒAction
            observation = await self._run_action(action)
            
            # 5. è®°å½•Observationåˆ°äº‹ä»¶æµ
            await self.event_stream.add_event(observation, EventSource.ENVIRONMENT)
            
            # 6. æ›´æ–°çŠ¶æ€
            self._update_state(action, observation)
            
        except Exception as e:
            # é”™è¯¯å¤„ç†
            error_obs = ErrorObservation(content=f"Error in step: {str(e)}")
            await self.event_stream.add_event(error_obs, EventSource.ENVIRONMENT)
    
    async def _run_action(self, action: Action) -> Observation:
        """æ‰§è¡Œå…·ä½“çš„Action"""
        
        if isinstance(action, CmdRunAction):
            return await self.runtime.run_command(action)
        
        elif isinstance(action, FileReadAction):
            return await self.runtime.read_file(action)
        
        elif isinstance(action, FileEditAction):
            return await self.runtime.edit_file(action)
        
        elif isinstance(action, BrowseURLAction):
            return await self.runtime.browse_url(action)
        
        elif isinstance(action, IPythonRunCellAction):
            return await self.runtime.run_ipython(action)
        
        else:
            return ErrorObservation(
                content=f"Unknown action type: {type(action)}"
            )
    
    def _validate_action(self, action: Action) -> bool:
        """éªŒè¯Actionçš„å®‰å…¨æ€§å’Œæœ‰æ•ˆæ€§"""
        
        # åŸºæœ¬éªŒè¯
        if not hasattr(action, 'validate') or not action.validate():
            return False
        
        # å®‰å…¨æ£€æŸ¥
        if hasattr(action, 'security_risk'):
            risk_level = action.security_risk
            if risk_level and risk_level.value > 1:  # HIGH risk
                return False
        
        return True


# ===== 4. Runtimeæ‰§è¡Œå±‚ =====
# æ–‡ä»¶ï¼šopenhands/runtime/base.py

class Runtime:
    """RuntimeåŸºç±»ï¼Œå®šä¹‰ç¯å¢ƒäº¤äº’æ¥å£"""
    
    async def run_command(self, action: CmdRunAction) -> CmdOutputObservation:
        """æ‰§è¡Œbashå‘½ä»¤"""
        
        try:
            # 1. å‡†å¤‡æ‰§è¡Œç¯å¢ƒ
            env = self._prepare_environment()
            cwd = action.cwd or self.working_dir
            
            # 2. æ‰§è¡Œå‘½ä»¤
            result = await self._execute_bash_command(
                command=action.command,
                cwd=cwd,
                env=env,
                timeout=30
            )
            
            # 3. å¤„ç†æ‰§è¡Œç»“æœ
            metadata = CmdOutputMetadata(
                exit_code=result.exit_code,
                pid=result.pid,
                working_dir=result.cwd,
                username=result.username,
                hostname=result.hostname
            )
            
            # 4. åˆ›å»ºObservation
            observation = CmdOutputObservation(
                content=result.stdout + result.stderr,
                command=action.command,
                metadata=metadata,
                hidden=action.hidden
            )
            
            return observation
            
        except Exception as e:
            # é”™è¯¯å¤„ç†
            return ErrorObservation(
                content=f"Command execution failed: {str(e)}"
            )
    
    async def _execute_bash_command(
        self, 
        command: str, 
        cwd: str, 
        env: dict,
        timeout: int = 30
    ) -> CommandResult:
        """å®é™…æ‰§è¡Œbashå‘½ä»¤çš„åº•å±‚æ–¹æ³•"""
        
        import asyncio
        import subprocess
        
        # åˆ›å»ºè¿›ç¨‹
        process = await asyncio.create_subprocess_shell(
            command,
            stdout=asyncio.subprocess.PIPE,
            stderr=asyncio.subprocess.PIPE,
            cwd=cwd,
            env=env
        )
        
        try:
            # ç­‰å¾…æ‰§è¡Œå®Œæˆ
            stdout, stderr = await asyncio.wait_for(
                process.communicate(), 
                timeout=timeout
            )
            
            return CommandResult(
                stdout=stdout.decode('utf-8', errors='replace'),
                stderr=stderr.decode('utf-8', errors='replace'),
                exit_code=process.returncode,
                pid=process.pid,
                cwd=cwd
            )
            
        except asyncio.TimeoutError:
            # è¶…æ—¶å¤„ç†
            process.kill()
            await process.wait()
            
            return CommandResult(
                stdout="",
                stderr=f"Command timed out after {timeout} seconds",
                exit_code=-1,
                pid=process.pid,
                cwd=cwd
            )


# ===== 5. Observationå®šä¹‰å’Œå¤„ç† =====
# æ–‡ä»¶ï¼šopenhands/events/observation/commands.py

from dataclasses import dataclass, field
from openhands.events.observation.observation import Observation

@dataclass
class CmdOutputObservation(Observation):
    """å‘½ä»¤æ‰§è¡Œç»“æœçš„Observation"""
    
    command: str  # æ‰§è¡Œçš„å‘½ä»¤
    metadata: CmdOutputMetadata = field(default_factory=CmdOutputMetadata)
    hidden: bool = False  # æ˜¯å¦éšè—è¾“å‡º
    
    def __init__(
        self,
        content: str,
        command: str,
        metadata: CmdOutputMetadata | None = None,
        hidden: bool = False,
        **kwargs
    ):
        # æˆªæ–­è¿‡é•¿çš„å†…å®¹
        truncated_content = self._maybe_truncate(content)
        super().__init__(truncated_content)
        
        self.command = command
        self.metadata = metadata or CmdOutputMetadata()
        self.hidden = hidden
    
    @staticmethod
    def _maybe_truncate(content: str, max_size: int = 30000) -> str:
        """æˆªæ–­è¿‡é•¿çš„å†…å®¹"""
        if len(content) <= max_size:
            return content
        
        half = max_size // 2
        return (
            content[:half] + 
            '\n[... Output truncated due to length ...]\n' + 
            content[-half:]
        )
    
    @property
    def exit_code(self) -> int:
        """å‘½ä»¤é€€å‡ºç """
        return self.metadata.exit_code
    
    @property
    def success(self) -> bool:
        """å‘½ä»¤æ˜¯å¦æˆåŠŸæ‰§è¡Œ"""
        return self.exit_code == 0
    
    @property
    def error(self) -> bool:
        """å‘½ä»¤æ˜¯å¦æ‰§è¡Œå¤±è´¥"""
        return not self.success
    
    @property
    def message(self) -> str:
        """Observationçš„æè¿°ä¿¡æ¯"""
        return f'Command `{self.command}` executed with exit code {self.exit_code}.'
    
    def __str__(self) -> str:
        """Observationçš„å­—ç¬¦ä¸²è¡¨ç¤º"""
        return (
            f'**CmdOutputObservation (exit_code={self.exit_code})**\n'
            f'Command: {self.command}\n'
            f'Output:\n{self.content}'
        )
    
    def to_agent_observation(self) -> str:
        """è½¬æ¢ä¸ºAgentå¯è¯»çš„æ ¼å¼"""
        ret = self.content
        
        # æ·»åŠ ä¸Šä¸‹æ–‡ä¿¡æ¯
        if self.metadata.working_dir:
            ret += f'\n[Current working directory: {self.metadata.working_dir}]'
        
        if self.metadata.py_interpreter_path:
            ret += f'\n[Python interpreter: {self.metadata.py_interpreter_path}]'
        
        if self.metadata.exit_code != -1:
            ret += f'\n[Command finished with exit code {self.metadata.exit_code}]'
        
        return ret


# ===== 6. å…ƒæ•°æ®å¤„ç† =====
# æ–‡ä»¶ï¼šopenhands/events/observation/commands.py

from pydantic import BaseModel
import json
import re

class CmdOutputMetadata(BaseModel):
    """å‘½ä»¤æ‰§è¡Œçš„å…ƒæ•°æ®"""
    
    exit_code: int = -1
    pid: int = -1
    username: str | None = None
    hostname: str | None = None
    working_dir: str | None = None
    py_interpreter_path: str | None = None
    prefix: str = ''
    suffix: str = ''
    
    @classmethod
    def to_ps1_prompt(cls) -> str:
        """ç”ŸæˆPS1æç¤ºç¬¦ï¼Œç”¨äºæ•è·å…ƒæ•°æ®"""
        prompt = '\n###PS1JSON###\n'
        json_str = json.dumps({
            'pid': '$!',
            'exit_code': '$?',
            'username': r'\u',
            'hostname': r'\h',
            'working_dir': r'$(pwd)',
            'py_interpreter_path': r'$(which python 2>/dev/null || echo "")',
        }, indent=2)
        
        prompt += json_str.replace('"', r'\"')
        prompt += '\n###PS1END###\n'
        return prompt
    
    @classmethod
    def from_ps1_output(cls, output: str) -> 'CmdOutputMetadata':
        """ä»PS1è¾“å‡ºä¸­è§£æå…ƒæ•°æ®"""
        pattern = r'###PS1JSON###\n(.*?)\n###PS1END###'
        match = re.search(pattern, output, re.DOTALL)
        
        if not match:
            return cls()
        
        try:
            metadata = json.loads(match.group(1))
            return cls(**metadata)
        except json.JSONDecodeError:
            return cls()


# ===== 7. äº‹ä»¶æµç®¡ç† =====
# æ–‡ä»¶ï¼šopenhands/events/stream.py

from typing import List, Optional
from openhands.events.event import Event, EventSource

class EventStream:
    """äº‹ä»¶æµç®¡ç†å™¨"""
    
    def __init__(self):
        self.events: List[Event] = []
        self.subscribers: List[EventStreamSubscriber] = []
    
    async def add_event(self, event: Event, source: EventSource) -> None:
        """æ·»åŠ äº‹ä»¶åˆ°æµä¸­"""
        
        # è®¾ç½®äº‹ä»¶å±æ€§
        event._source = source
        event._id = len(self.events)
        event._timestamp = datetime.now()
        
        # æ·»åŠ åˆ°äº‹ä»¶åˆ—è¡¨
        self.events.append(event)
        
        # é€šçŸ¥è®¢é˜…è€…
        for subscriber in self.subscribers:
            await subscriber.on_event(event)
    
    def get_events(
        self, 
        start_id: int = 0, 
        end_id: Optional[int] = None
    ) -> List[Event]:
        """è·å–æŒ‡å®šèŒƒå›´çš„äº‹ä»¶"""
        
        if end_id is None:
            return self.events[start_id:]
        else:
            return self.events[start_id:end_id + 1]
    
    def get_latest_events(self, count: int = 10) -> List[Event]:
        """è·å–æœ€æ–°çš„Nä¸ªäº‹ä»¶"""
        return self.events[-count:] if self.events else []
    
    def filter_events(self, event_type: type) -> List[Event]:
        """æŒ‰ç±»å‹è¿‡æ»¤äº‹ä»¶"""
        return [event for event in self.events if isinstance(event, event_type)]


# ===== 8. å®Œæ•´çš„ä½¿ç”¨ç¤ºä¾‹ =====
# æ–‡ä»¶ï¼šexample_usage.py

async def main():
    """å®Œæ•´çš„AAOå¾ªç¯ä½¿ç”¨ç¤ºä¾‹"""
    
    # 1. åˆå§‹åŒ–ç»„ä»¶
    llm = LLM(config=LLMConfig(model="gpt-4"))
    agent = CodeActAgent(llm=llm, config=AgentConfig())
    runtime = DockerRuntime(config=SandboxConfig())
    event_stream = EventStream()
    
    # 2. åˆ›å»ºæ§åˆ¶å™¨
    controller = AgentController(
        agent=agent,
        runtime=runtime,
        event_stream=event_stream
    )
    
    # 3. æ·»åŠ åˆå§‹æ¶ˆæ¯
    initial_message = MessageAction(
        content="Please list the files in the current directory"
    )
    await event_stream.add_event(initial_message, EventSource.USER)
    
    # 4. æ‰§è¡ŒAAOå¾ªç¯
    max_iterations = 10
    for i in range(max_iterations):
        
        # æ£€æŸ¥æ˜¯å¦å®Œæˆ
        if controller.state.agent_state == AgentState.FINISHED:
            break
        
        # æ‰§è¡Œä¸€æ­¥
        await controller.step()
        
        # æ£€æŸ¥é”™è¯¯çŠ¶æ€
        if controller.state.agent_state == AgentState.ERROR:
            print("Agent encountered an error")
            break
    
    # 5. è¾“å‡ºç»“æœ
    print("=== Event Stream ===")
    for event in event_stream.get_events():
        print(f"{event._source}: {event}")
        print("-" * 50)

if __name__ == "__main__":
    import asyncio
    asyncio.run(main())
```

## ğŸ”§ å®ç”¨å·¥å…·å’Œè¾…åŠ©å‡½æ•°

### 1. Actionè§£æå·¥å…·

```python
# æ–‡ä»¶ï¼šopenhands/controller/action_parser.py

class ActionParser:
    """Actionè§£æå·¥å…·"""
    
    @staticmethod
    def parse_llm_response(response: str) -> Action:
        """è§£æLLMå“åº”ï¼Œæå–Action"""
        
        # å‘½ä»¤æ‰§è¡Œ
        if '<execute_bash>' in response:
            command = ActionParser._extract_tag_content(response, 'execute_bash')
            return CmdRunAction(command=command)
        
        # Pythonä»£ç æ‰§è¡Œ
        elif '<execute_ipython>' in response:
            code = ActionParser._extract_tag_content(response, 'execute_ipython')
            return IPythonRunCellAction(code=code)
        
        # æ–‡ä»¶è¯»å–
        elif '<read_file>' in response:
            path = ActionParser._extract_tag_content(response, 'read_file')
            return FileReadAction(path=path)
        
        # æ–‡ä»¶ç¼–è¾‘
        elif '<edit_file>' in response:
            content = ActionParser._extract_tag_content(response, 'edit_file')
            path, file_text = ActionParser._parse_edit_content(content)
            return FileEditAction(path=path, file_text=file_text)
        
        # é»˜è®¤æ¶ˆæ¯
        else:
            return MessageAction(content=response)
    
    @staticmethod
    def _extract_tag_content(text: str, tag: str) -> str:
        """æå–XMLæ ‡ç­¾å†…å®¹"""
        import re
        pattern = f'<{tag}>(.*?)</{tag}>'
        match = re.search(pattern, text, re.DOTALL)
        return match.group(1).strip() if match else ""
    
    @staticmethod
    def _parse_edit_content(content: str) -> tuple[str, str]:
        """è§£ææ–‡ä»¶ç¼–è¾‘å†…å®¹"""
        lines = content.strip().split('\n')
        if lines and lines[0].startswith('path:'):
            path = lines[0].replace('path:', '').strip()
            file_text = '\n'.join(lines[1:])
            return path, file_text
        return "", content
```

### 2. çŠ¶æ€ç®¡ç†å·¥å…·

```python
# æ–‡ä»¶ï¼šopenhands/controller/state/state_manager.py

class StateManager:
    """çŠ¶æ€ç®¡ç†å·¥å…·"""
    
    def __init__(self, initial_state: AgentState = AgentState.INIT):
        self.current_state = initial_state
        self.state_history: List[AgentState] = [initial_state]
        self.transition_callbacks: Dict[AgentState, List[Callable]] = {}
    
    def transition_to(self, new_state: AgentState) -> bool:
        """çŠ¶æ€è½¬æ¢"""
        
        if not self._is_valid_transition(self.current_state, new_state):
            return False
        
        # è®°å½•å†å²
        self.state_history.append(new_state)
        old_state = self.current_state
        self.current_state = new_state
        
        # è§¦å‘å›è°ƒ
        self._trigger_callbacks(old_state, new_state)
        
        return True
    
    def _is_valid_transition(self, from_state: AgentState, to_state: AgentState) -> bool:
        """æ£€æŸ¥çŠ¶æ€è½¬æ¢æ˜¯å¦æœ‰æ•ˆ"""
        
        valid_transitions = {
            AgentState.INIT: [AgentState.RUNNING, AgentState.ERROR],
            AgentState.RUNNING: [AgentState.PAUSED, AgentState.FINISHED, AgentState.ERROR],
            AgentState.PAUSED: [AgentState.RUNNING, AgentState.FINISHED, AgentState.ERROR],
            AgentState.FINISHED: [],  # ç»ˆæ€
            AgentState.ERROR: [AgentState.RUNNING, AgentState.INIT],  # å¯ä»¥é‡å¯
        }
        
        return to_state in valid_transitions.get(from_state, [])
    
    def register_callback(self, state: AgentState, callback: Callable):
        """æ³¨å†ŒçŠ¶æ€è½¬æ¢å›è°ƒ"""
        if state not in self.transition_callbacks:
            self.transition_callbacks[state] = []
        self.transition_callbacks[state].append(callback)
    
    def _trigger_callbacks(self, old_state: AgentState, new_state: AgentState):
        """è§¦å‘çŠ¶æ€è½¬æ¢å›è°ƒ"""
        for callback in self.transition_callbacks.get(new_state, []):
            try:
                callback(old_state, new_state)
            except Exception as e:
                print(f"Callback error: {e}")
```

### 3. é”™è¯¯å¤„ç†å·¥å…·

```python
# æ–‡ä»¶ï¼šopenhands/core/error_handler.py

class ErrorHandler:
    """é”™è¯¯å¤„ç†å·¥å…·"""
    
    @staticmethod
    def handle_action_error(action: Action, error: Exception) -> ErrorObservation:
        """å¤„ç†Actionæ‰§è¡Œé”™è¯¯"""
        
        error_type = type(error).__name__
        error_message = str(error)
        
        # æ ¹æ®é”™è¯¯ç±»å‹æä¾›ä¸åŒçš„å¤„ç†
        if isinstance(error, TimeoutError):
            content = f"Action timed out: {error_message}"
        elif isinstance(error, PermissionError):
            content = f"Permission denied: {error_message}"
        elif isinstance(error, FileNotFoundError):
            content = f"File not found: {error_message}"
        else:
            content = f"Unexpected error ({error_type}): {error_message}"
        
        return ErrorObservation(
            content=content,
            error_type=error_type,
            action_type=type(action).__name__
        )
    
    @staticmethod
    def is_recoverable_error(error: Exception) -> bool:
        """åˆ¤æ–­é”™è¯¯æ˜¯å¦å¯æ¢å¤"""
        
        recoverable_errors = [
            TimeoutError,
            ConnectionError,
            FileNotFoundError,
            PermissionError
        ]
        
        return any(isinstance(error, err_type) for err_type in recoverable_errors)
    
    @staticmethod
    def suggest_recovery_action(error: Exception) -> str:
        """å»ºè®®æ¢å¤æ“ä½œ"""
        
        if isinstance(error, TimeoutError):
            return "Try reducing the operation scope or increasing timeout"
        elif isinstance(error, PermissionError):
            return "Check file permissions or run with appropriate privileges"
        elif isinstance(error, FileNotFoundError):
            return "Verify the file path exists"
        else:
            return "Review the operation and try again"
```

## ğŸ¯ æœ€ä½³å®è·µå»ºè®®

### 1. Actionè®¾è®¡åŸåˆ™

```python
# å¥½çš„Actionè®¾è®¡ç¤ºä¾‹
@dataclass
class WellDesignedAction(Action):
    # 1. æ˜ç¡®çš„å‚æ•°ç±»å‹
    target_path: str
    operation_mode: Literal['read', 'write', 'append']
    
    # 2. åˆç†çš„é»˜è®¤å€¼
    encoding: str = 'utf-8'
    create_if_missing: bool = False
    
    # 3. éªŒè¯æ–¹æ³•
    def validate(self) -> bool:
        if not self.target_path or not self.target_path.strip():
            return False
        
        if self.operation_mode not in ['read', 'write', 'append']:
            return False
        
        return True
    
    # 4. æ¸…æ™°çš„å­—ç¬¦ä¸²è¡¨ç¤º
    def __str__(self) -> str:
        return f"FileOperation(path={self.target_path}, mode={self.operation_mode})"
```

### 2. Observationè®¾è®¡åŸåˆ™

```python
# å¥½çš„Observationè®¾è®¡ç¤ºä¾‹
@dataclass
class WellDesignedObservation(Observation):
    # 1. ç»“æ„åŒ–çš„ç»“æœæ•°æ®
    operation_result: Dict[str, Any]
    
    # 2. æ˜ç¡®çš„çŠ¶æ€æŒ‡ç¤º
    success: bool
    error_code: Optional[int] = None
    
    # 3. æœ‰ç”¨çš„å±æ€§æ–¹æ³•
    @property
    def is_partial_success(self) -> bool:
        return self.success and self.error_code is not None
    
    # 4. æ ¼å¼åŒ–çš„è¾“å‡º
    def to_agent_observation(self) -> str:
        if self.success:
            return f"Operation completed successfully: {self.operation_result}"
        else:
            return f"Operation failed (code {self.error_code}): {self.content}"
```

### 3. é”™è¯¯å¤„ç†æœ€ä½³å®è·µ

```python
# åœ¨Agentä¸­çš„é”™è¯¯å¤„ç†
class RobustAgent(Agent):
    async def step(self, state: State) -> Action:
        try:
            # æ­£å¸¸çš„å†³ç­–é€»è¾‘
            return await self._make_decision(state)
        
        except LLMError as e:
            # LLMç›¸å…³é”™è¯¯
            return MessageAction(content=f"LLM error: {e}")
        
        except ValidationError as e:
            # éªŒè¯é”™è¯¯
            return MessageAction(content=f"Validation failed: {e}")
        
        except Exception as e:
            # æœªé¢„æœŸçš„é”™è¯¯
            logger.error(f"Unexpected error in agent step: {e}")
            return AgentFinishAction(
                outputs={"error": str(e)},
                thought="Encountered unexpected error, finishing task"
            )

# åœ¨Runtimeä¸­çš„é”™è¯¯å¤„ç†
class RobustRuntime(Runtime):
    async def run_command(self, action: CmdRunAction) -> Observation:
        try:
            # æ­£å¸¸æ‰§è¡Œé€»è¾‘
            return await self._execute_command(action)
        
        except TimeoutError:
            return ErrorObservation(
                content=f"Command '{action.command}' timed out"
            )
        
        except PermissionError:
            return ErrorObservation(
                content=f"Permission denied for command '{action.command}'"
            )
        
        except Exception as e:
            return ErrorObservation(
                content=f"Unexpected error executing '{action.command}': {e}"
            )
```

## ğŸ”— ç›¸å…³èµ„æº

- [Agent-Action-Observationæ¨¡å¼è¯¦è§£](./agent-action-observation-pattern.md)
- [æ¨¡å—ä¾èµ–å…³ç³»å›¾](./module-dependency-diagrams.md)
- [OpenHandsæ¶æ„æ¦‚è§ˆ](../README.md)
- [æ·±å…¥ç†è§£æŒ‡å—](../stage2-deep-dive/README.md)