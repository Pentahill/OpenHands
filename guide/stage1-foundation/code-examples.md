# Agent-Action-Observation 代码示例详解

## 🎯 概述

本文档提供了OpenHands项目中Agent-Action-Observation模式的详细代码示例，帮助开发者理解具体的实现细节和最佳实践。

## 📝 完整的AAO循环示例

### 示例1：命令执行的完整流程

```python
# ===== 1. Agent决策阶段 =====
# 文件：openhands/agenthub/codeact_agent/codeact_agent.py

from openhands.controller.agent import Agent
from openhands.events.action import CmdRunAction
from openhands.core.schema import AgentState

class CodeActAgent(Agent):
    """代码执行专用Agent"""
    
    async def step(self, state: State) -> Action:
        """Agent的核心决策方法"""
        
        # 1. 获取当前对话历史
        messages = self._get_messages(state)
        
        # 2. 调用LLM进行推理
        response = await self.llm.acompletion(
            messages=messages,
            temperature=0.1,
            max_tokens=1000
        )
        
        # 3. 解析LLM响应，提取Action
        action = self._parse_response(response)
        
        # 4. 添加思考过程
        if hasattr(action, 'thought'):
            action.thought = self._extract_thought(response)
        
        return action
    
    def _parse_response(self, response: str) -> Action:
        """解析LLM响应，创建相应的Action"""
        
        # 检查是否包含命令执行请求
        if '<execute_bash>' in response:
            command = self._extract_bash_command(response)
            return CmdRunAction(
                command=command,
                thought=self._extract_thought(response)
            )
        
        # 检查是否包含Python代码执行
        elif '<execute_ipython>' in response:
            code = self._extract_python_code(response)
            return IPythonRunCellAction(
                code=code,
                thought=self._extract_thought(response)
            )
        
        # 默认返回消息Action
        return MessageAction(content=response)
    
    def _extract_bash_command(self, response: str) -> str:
        """从响应中提取bash命令"""
        import re
        pattern = r'<execute_bash>\s*(.*?)\s*</execute_bash>'
        match = re.search(pattern, response, re.DOTALL)
        return match.group(1).strip() if match else ""


# ===== 2. Action定义和处理 =====
# 文件：openhands/events/action/commands.py

from dataclasses import dataclass
from typing import ClassVar
from openhands.events.action.action import Action

@dataclass
class CmdRunAction(Action):
    """命令执行Action"""
    
    command: str  # 要执行的命令
    is_input: bool = False  # 是否为输入到运行中的进程
    thought: str = ''  # Agent的思考过程
    blocking: bool = False  # 是否阻塞执行
    cwd: str | None = None  # 工作目录
    hidden: bool = False  # 是否隐藏输出
    
    # 类属性
    action: str = "run"
    runnable: ClassVar[bool] = True
    
    @property
    def message(self) -> str:
        """Action的描述信息"""
        return f'Running command: {self.command}'
    
    def __str__(self) -> str:
        """Action的字符串表示"""
        ret = f'**CmdRunAction (source={self.source})**\n'
        if self.thought:
            ret += f'THOUGHT: {self.thought}\n'
        ret += f'COMMAND:\n{self.command}'
        return ret
    
    def validate(self) -> bool:
        """验证Action的有效性"""
        if not self.command or not self.command.strip():
            return False
        
        # 检查危险命令
        dangerous_commands = ['rm -rf /', 'format', 'del /f /s /q']
        for dangerous in dangerous_commands:
            if dangerous in self.command.lower():
                return False
        
        return True


# ===== 3. 控制器处理逻辑 =====
# 文件：openhands/controller/agent_controller.py

class AgentController:
    """Agent控制器，负责协调Agent、Runtime和事件流"""
    
    def __init__(self, agent: Agent, runtime: Runtime, event_stream: EventStream):
        self.agent = agent
        self.runtime = runtime
        self.event_stream = event_stream
        self.state = State()
    
    async def step(self) -> None:
        """执行一个完整的AAO循环"""
        
        try:
            # 1. Agent决策阶段
            action = await self.agent.step(self.state)
            
            # 2. 验证Action
            if not self._validate_action(action):
                error_obs = ErrorObservation(
                    content="Invalid action generated by agent"
                )
                await self.event_stream.add_event(error_obs, EventSource.ENVIRONMENT)
                return
            
            # 3. 记录Action到事件流
            await self.event_stream.add_event(action, EventSource.AGENT)
            
            # 4. 执行Action
            observation = await self._run_action(action)
            
            # 5. 记录Observation到事件流
            await self.event_stream.add_event(observation, EventSource.ENVIRONMENT)
            
            # 6. 更新状态
            self._update_state(action, observation)
            
        except Exception as e:
            # 错误处理
            error_obs = ErrorObservation(content=f"Error in step: {str(e)}")
            await self.event_stream.add_event(error_obs, EventSource.ENVIRONMENT)
    
    async def _run_action(self, action: Action) -> Observation:
        """执行具体的Action"""
        
        if isinstance(action, CmdRunAction):
            return await self.runtime.run_command(action)
        
        elif isinstance(action, FileReadAction):
            return await self.runtime.read_file(action)
        
        elif isinstance(action, FileEditAction):
            return await self.runtime.edit_file(action)
        
        elif isinstance(action, BrowseURLAction):
            return await self.runtime.browse_url(action)
        
        elif isinstance(action, IPythonRunCellAction):
            return await self.runtime.run_ipython(action)
        
        else:
            return ErrorObservation(
                content=f"Unknown action type: {type(action)}"
            )
    
    def _validate_action(self, action: Action) -> bool:
        """验证Action的安全性和有效性"""
        
        # 基本验证
        if not hasattr(action, 'validate') or not action.validate():
            return False
        
        # 安全检查
        if hasattr(action, 'security_risk'):
            risk_level = action.security_risk
            if risk_level and risk_level.value > 1:  # HIGH risk
                return False
        
        return True


# ===== 4. Runtime执行层 =====
# 文件：openhands/runtime/base.py

class Runtime:
    """Runtime基类，定义环境交互接口"""
    
    async def run_command(self, action: CmdRunAction) -> CmdOutputObservation:
        """执行bash命令"""
        
        try:
            # 1. 准备执行环境
            env = self._prepare_environment()
            cwd = action.cwd or self.working_dir
            
            # 2. 执行命令
            result = await self._execute_bash_command(
                command=action.command,
                cwd=cwd,
                env=env,
                timeout=30
            )
            
            # 3. 处理执行结果
            metadata = CmdOutputMetadata(
                exit_code=result.exit_code,
                pid=result.pid,
                working_dir=result.cwd,
                username=result.username,
                hostname=result.hostname
            )
            
            # 4. 创建Observation
            observation = CmdOutputObservation(
                content=result.stdout + result.stderr,
                command=action.command,
                metadata=metadata,
                hidden=action.hidden
            )
            
            return observation
            
        except Exception as e:
            # 错误处理
            return ErrorObservation(
                content=f"Command execution failed: {str(e)}"
            )
    
    async def _execute_bash_command(
        self, 
        command: str, 
        cwd: str, 
        env: dict,
        timeout: int = 30
    ) -> CommandResult:
        """实际执行bash命令的底层方法"""
        
        import asyncio
        import subprocess
        
        # 创建进程
        process = await asyncio.create_subprocess_shell(
            command,
            stdout=asyncio.subprocess.PIPE,
            stderr=asyncio.subprocess.PIPE,
            cwd=cwd,
            env=env
        )
        
        try:
            # 等待执行完成
            stdout, stderr = await asyncio.wait_for(
                process.communicate(), 
                timeout=timeout
            )
            
            return CommandResult(
                stdout=stdout.decode('utf-8', errors='replace'),
                stderr=stderr.decode('utf-8', errors='replace'),
                exit_code=process.returncode,
                pid=process.pid,
                cwd=cwd
            )
            
        except asyncio.TimeoutError:
            # 超时处理
            process.kill()
            await process.wait()
            
            return CommandResult(
                stdout="",
                stderr=f"Command timed out after {timeout} seconds",
                exit_code=-1,
                pid=process.pid,
                cwd=cwd
            )


# ===== 5. Observation定义和处理 =====
# 文件：openhands/events/observation/commands.py

from dataclasses import dataclass, field
from openhands.events.observation.observation import Observation

@dataclass
class CmdOutputObservation(Observation):
    """命令执行结果的Observation"""
    
    command: str  # 执行的命令
    metadata: CmdOutputMetadata = field(default_factory=CmdOutputMetadata)
    hidden: bool = False  # 是否隐藏输出
    
    def __init__(
        self,
        content: str,
        command: str,
        metadata: CmdOutputMetadata | None = None,
        hidden: bool = False,
        **kwargs
    ):
        # 截断过长的内容
        truncated_content = self._maybe_truncate(content)
        super().__init__(truncated_content)
        
        self.command = command
        self.metadata = metadata or CmdOutputMetadata()
        self.hidden = hidden
    
    @staticmethod
    def _maybe_truncate(content: str, max_size: int = 30000) -> str:
        """截断过长的内容"""
        if len(content) <= max_size:
            return content
        
        half = max_size // 2
        return (
            content[:half] + 
            '\n[... Output truncated due to length ...]\n' + 
            content[-half:]
        )
    
    @property
    def exit_code(self) -> int:
        """命令退出码"""
        return self.metadata.exit_code
    
    @property
    def success(self) -> bool:
        """命令是否成功执行"""
        return self.exit_code == 0
    
    @property
    def error(self) -> bool:
        """命令是否执行失败"""
        return not self.success
    
    @property
    def message(self) -> str:
        """Observation的描述信息"""
        return f'Command `{self.command}` executed with exit code {self.exit_code}.'
    
    def __str__(self) -> str:
        """Observation的字符串表示"""
        return (
            f'**CmdOutputObservation (exit_code={self.exit_code})**\n'
            f'Command: {self.command}\n'
            f'Output:\n{self.content}'
        )
    
    def to_agent_observation(self) -> str:
        """转换为Agent可读的格式"""
        ret = self.content
        
        # 添加上下文信息
        if self.metadata.working_dir:
            ret += f'\n[Current working directory: {self.metadata.working_dir}]'
        
        if self.metadata.py_interpreter_path:
            ret += f'\n[Python interpreter: {self.metadata.py_interpreter_path}]'
        
        if self.metadata.exit_code != -1:
            ret += f'\n[Command finished with exit code {self.metadata.exit_code}]'
        
        return ret


# ===== 6. 元数据处理 =====
# 文件：openhands/events/observation/commands.py

from pydantic import BaseModel
import json
import re

class CmdOutputMetadata(BaseModel):
    """命令执行的元数据"""
    
    exit_code: int = -1
    pid: int = -1
    username: str | None = None
    hostname: str | None = None
    working_dir: str | None = None
    py_interpreter_path: str | None = None
    prefix: str = ''
    suffix: str = ''
    
    @classmethod
    def to_ps1_prompt(cls) -> str:
        """生成PS1提示符，用于捕获元数据"""
        prompt = '\n###PS1JSON###\n'
        json_str = json.dumps({
            'pid': '$!',
            'exit_code': '$?',
            'username': r'\u',
            'hostname': r'\h',
            'working_dir': r'$(pwd)',
            'py_interpreter_path': r'$(which python 2>/dev/null || echo "")',
        }, indent=2)
        
        prompt += json_str.replace('"', r'\"')
        prompt += '\n###PS1END###\n'
        return prompt
    
    @classmethod
    def from_ps1_output(cls, output: str) -> 'CmdOutputMetadata':
        """从PS1输出中解析元数据"""
        pattern = r'###PS1JSON###\n(.*?)\n###PS1END###'
        match = re.search(pattern, output, re.DOTALL)
        
        if not match:
            return cls()
        
        try:
            metadata = json.loads(match.group(1))
            return cls(**metadata)
        except json.JSONDecodeError:
            return cls()


# ===== 7. 事件流管理 =====
# 文件：openhands/events/stream.py

from typing import List, Optional
from openhands.events.event import Event, EventSource

class EventStream:
    """事件流管理器"""
    
    def __init__(self):
        self.events: List[Event] = []
        self.subscribers: List[EventStreamSubscriber] = []
    
    async def add_event(self, event: Event, source: EventSource) -> None:
        """添加事件到流中"""
        
        # 设置事件属性
        event._source = source
        event._id = len(self.events)
        event._timestamp = datetime.now()
        
        # 添加到事件列表
        self.events.append(event)
        
        # 通知订阅者
        for subscriber in self.subscribers:
            await subscriber.on_event(event)
    
    def get_events(
        self, 
        start_id: int = 0, 
        end_id: Optional[int] = None
    ) -> List[Event]:
        """获取指定范围的事件"""
        
        if end_id is None:
            return self.events[start_id:]
        else:
            return self.events[start_id:end_id + 1]
    
    def get_latest_events(self, count: int = 10) -> List[Event]:
        """获取最新的N个事件"""
        return self.events[-count:] if self.events else []
    
    def filter_events(self, event_type: type) -> List[Event]:
        """按类型过滤事件"""
        return [event for event in self.events if isinstance(event, event_type)]


# ===== 8. 完整的使用示例 =====
# 文件：example_usage.py

async def main():
    """完整的AAO循环使用示例"""
    
    # 1. 初始化组件
    llm = LLM(config=LLMConfig(model="gpt-4"))
    agent = CodeActAgent(llm=llm, config=AgentConfig())
    runtime = DockerRuntime(config=SandboxConfig())
    event_stream = EventStream()
    
    # 2. 创建控制器
    controller = AgentController(
        agent=agent,
        runtime=runtime,
        event_stream=event_stream
    )
    
    # 3. 添加初始消息
    initial_message = MessageAction(
        content="Please list the files in the current directory"
    )
    await event_stream.add_event(initial_message, EventSource.USER)
    
    # 4. 执行AAO循环
    max_iterations = 10
    for i in range(max_iterations):
        
        # 检查是否完成
        if controller.state.agent_state == AgentState.FINISHED:
            break
        
        # 执行一步
        await controller.step()
        
        # 检查错误状态
        if controller.state.agent_state == AgentState.ERROR:
            print("Agent encountered an error")
            break
    
    # 5. 输出结果
    print("=== Event Stream ===")
    for event in event_stream.get_events():
        print(f"{event._source}: {event}")
        print("-" * 50)

if __name__ == "__main__":
    import asyncio
    asyncio.run(main())
```

## 🔧 实用工具和辅助函数

### 1. Action解析工具

```python
# 文件：openhands/controller/action_parser.py

class ActionParser:
    """Action解析工具"""
    
    @staticmethod
    def parse_llm_response(response: str) -> Action:
        """解析LLM响应，提取Action"""
        
        # 命令执行
        if '<execute_bash>' in response:
            command = ActionParser._extract_tag_content(response, 'execute_bash')
            return CmdRunAction(command=command)
        
        # Python代码执行
        elif '<execute_ipython>' in response:
            code = ActionParser._extract_tag_content(response, 'execute_ipython')
            return IPythonRunCellAction(code=code)
        
        # 文件读取
        elif '<read_file>' in response:
            path = ActionParser._extract_tag_content(response, 'read_file')
            return FileReadAction(path=path)
        
        # 文件编辑
        elif '<edit_file>' in response:
            content = ActionParser._extract_tag_content(response, 'edit_file')
            path, file_text = ActionParser._parse_edit_content(content)
            return FileEditAction(path=path, file_text=file_text)
        
        # 默认消息
        else:
            return MessageAction(content=response)
    
    @staticmethod
    def _extract_tag_content(text: str, tag: str) -> str:
        """提取XML标签内容"""
        import re
        pattern = f'<{tag}>(.*?)</{tag}>'
        match = re.search(pattern, text, re.DOTALL)
        return match.group(1).strip() if match else ""
    
    @staticmethod
    def _parse_edit_content(content: str) -> tuple[str, str]:
        """解析文件编辑内容"""
        lines = content.strip().split('\n')
        if lines and lines[0].startswith('path:'):
            path = lines[0].replace('path:', '').strip()
            file_text = '\n'.join(lines[1:])
            return path, file_text
        return "", content
```

### 2. 状态管理工具

```python
# 文件：openhands/controller/state/state_manager.py

class StateManager:
    """状态管理工具"""
    
    def __init__(self, initial_state: AgentState = AgentState.INIT):
        self.current_state = initial_state
        self.state_history: List[AgentState] = [initial_state]
        self.transition_callbacks: Dict[AgentState, List[Callable]] = {}
    
    def transition_to(self, new_state: AgentState) -> bool:
        """状态转换"""
        
        if not self._is_valid_transition(self.current_state, new_state):
            return False
        
        # 记录历史
        self.state_history.append(new_state)
        old_state = self.current_state
        self.current_state = new_state
        
        # 触发回调
        self._trigger_callbacks(old_state, new_state)
        
        return True
    
    def _is_valid_transition(self, from_state: AgentState, to_state: AgentState) -> bool:
        """检查状态转换是否有效"""
        
        valid_transitions = {
            AgentState.INIT: [AgentState.RUNNING, AgentState.ERROR],
            AgentState.RUNNING: [AgentState.PAUSED, AgentState.FINISHED, AgentState.ERROR],
            AgentState.PAUSED: [AgentState.RUNNING, AgentState.FINISHED, AgentState.ERROR],
            AgentState.FINISHED: [],  # 终态
            AgentState.ERROR: [AgentState.RUNNING, AgentState.INIT],  # 可以重启
        }
        
        return to_state in valid_transitions.get(from_state, [])
    
    def register_callback(self, state: AgentState, callback: Callable):
        """注册状态转换回调"""
        if state not in self.transition_callbacks:
            self.transition_callbacks[state] = []
        self.transition_callbacks[state].append(callback)
    
    def _trigger_callbacks(self, old_state: AgentState, new_state: AgentState):
        """触发状态转换回调"""
        for callback in self.transition_callbacks.get(new_state, []):
            try:
                callback(old_state, new_state)
            except Exception as e:
                print(f"Callback error: {e}")
```

### 3. 错误处理工具

```python
# 文件：openhands/core/error_handler.py

class ErrorHandler:
    """错误处理工具"""
    
    @staticmethod
    def handle_action_error(action: Action, error: Exception) -> ErrorObservation:
        """处理Action执行错误"""
        
        error_type = type(error).__name__
        error_message = str(error)
        
        # 根据错误类型提供不同的处理
        if isinstance(error, TimeoutError):
            content = f"Action timed out: {error_message}"
        elif isinstance(error, PermissionError):
            content = f"Permission denied: {error_message}"
        elif isinstance(error, FileNotFoundError):
            content = f"File not found: {error_message}"
        else:
            content = f"Unexpected error ({error_type}): {error_message}"
        
        return ErrorObservation(
            content=content,
            error_type=error_type,
            action_type=type(action).__name__
        )
    
    @staticmethod
    def is_recoverable_error(error: Exception) -> bool:
        """判断错误是否可恢复"""
        
        recoverable_errors = [
            TimeoutError,
            ConnectionError,
            FileNotFoundError,
            PermissionError
        ]
        
        return any(isinstance(error, err_type) for err_type in recoverable_errors)
    
    @staticmethod
    def suggest_recovery_action(error: Exception) -> str:
        """建议恢复操作"""
        
        if isinstance(error, TimeoutError):
            return "Try reducing the operation scope or increasing timeout"
        elif isinstance(error, PermissionError):
            return "Check file permissions or run with appropriate privileges"
        elif isinstance(error, FileNotFoundError):
            return "Verify the file path exists"
        else:
            return "Review the operation and try again"
```

## 🎯 最佳实践建议

### 1. Action设计原则

```python
# 好的Action设计示例
@dataclass
class WellDesignedAction(Action):
    # 1. 明确的参数类型
    target_path: str
    operation_mode: Literal['read', 'write', 'append']
    
    # 2. 合理的默认值
    encoding: str = 'utf-8'
    create_if_missing: bool = False
    
    # 3. 验证方法
    def validate(self) -> bool:
        if not self.target_path or not self.target_path.strip():
            return False
        
        if self.operation_mode not in ['read', 'write', 'append']:
            return False
        
        return True
    
    # 4. 清晰的字符串表示
    def __str__(self) -> str:
        return f"FileOperation(path={self.target_path}, mode={self.operation_mode})"
```

### 2. Observation设计原则

```python
# 好的Observation设计示例
@dataclass
class WellDesignedObservation(Observation):
    # 1. 结构化的结果数据
    operation_result: Dict[str, Any]
    
    # 2. 明确的状态指示
    success: bool
    error_code: Optional[int] = None
    
    # 3. 有用的属性方法
    @property
    def is_partial_success(self) -> bool:
        return self.success and self.error_code is not None
    
    # 4. 格式化的输出
    def to_agent_observation(self) -> str:
        if self.success:
            return f"Operation completed successfully: {self.operation_result}"
        else:
            return f"Operation failed (code {self.error_code}): {self.content}"
```

### 3. 错误处理最佳实践

```python
# 在Agent中的错误处理
class RobustAgent(Agent):
    async def step(self, state: State) -> Action:
        try:
            # 正常的决策逻辑
            return await self._make_decision(state)
        
        except LLMError as e:
            # LLM相关错误
            return MessageAction(content=f"LLM error: {e}")
        
        except ValidationError as e:
            # 验证错误
            return MessageAction(content=f"Validation failed: {e}")
        
        except Exception as e:
            # 未预期的错误
            logger.error(f"Unexpected error in agent step: {e}")
            return AgentFinishAction(
                outputs={"error": str(e)},
                thought="Encountered unexpected error, finishing task"
            )

# 在Runtime中的错误处理
class RobustRuntime(Runtime):
    async def run_command(self, action: CmdRunAction) -> Observation:
        try:
            # 正常执行逻辑
            return await self._execute_command(action)
        
        except TimeoutError:
            return ErrorObservation(
                content=f"Command '{action.command}' timed out"
            )
        
        except PermissionError:
            return ErrorObservation(
                content=f"Permission denied for command '{action.command}'"
            )
        
        except Exception as e:
            return ErrorObservation(
                content=f"Unexpected error executing '{action.command}': {e}"
            )
```

## 🔗 相关资源

- [Agent-Action-Observation模式详解](./agent-action-observation-pattern.md)
- [模块依赖关系图](./module-dependency-diagrams.md)
- [OpenHands架构概览](../README.md)
- [深入理解指南](../stage2-deep-dive/README.md)