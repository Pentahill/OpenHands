# é˜¶æ®µå››å­¦ä¹ è„‘å›¾ï¼šæ‰©å±•å¼€å‘

```mermaid
mindmap
  root((é˜¶æ®µå››<br/>æ‰©å±•å¼€å‘<br/>4-6å‘¨))
    è‡ªå®šä¹‰å·¥å…·å¼€å‘
      å·¥å…·æ¶æ„
        BaseToolåŸºç±»
        å·¥å…·æ¥å£è§„èŒƒ
        æ‰§è¡Œå™¨æ¨¡å¼
        ç»“æœå¤„ç†
        é”™è¯¯æ¢å¤
      å·¥å…·ç±»å‹
        æ•°æ®å¤„ç†å·¥å…·
        APIé›†æˆå·¥å…·
        æ–‡ä»¶æ“ä½œå·¥å…·
        ç½‘ç»œå·¥å…·
        åˆ†æå·¥å…·
      é«˜çº§ç‰¹æ€§
        å¼‚æ­¥æ‰§è¡Œ
        æ‰¹å¤„ç†æ”¯æŒ
        ç¼“å­˜æœºåˆ¶
        æ€§èƒ½ä¼˜åŒ–
        ç›‘æ§é›†æˆ
      å·¥å…·ç”Ÿæ€
        å·¥å…·æ³¨å†Œ
        ä¾èµ–ç®¡ç†
        ç‰ˆæœ¬æ§åˆ¶
        æ–‡æ¡£ç”Ÿæˆ
        æµ‹è¯•æ¡†æ¶

    å¾®ä»£ç†å¼€å‘
      æ¶æ„è®¾è®¡
        å¾®ä»£ç†åŸºç±»
        è§¦å‘æœºåˆ¶
        ä¸Šä¸‹æ–‡ç®¡ç†
        çŸ¥è¯†åº“é›†æˆ
        åŠ¨æ€åŠ è½½
      ä¸“ä¸šåŒ–é¢†åŸŸ
        ä»£ç å®¡æŸ¥
        æ•°æ®åˆ†æ
        å®‰å…¨æ£€æŸ¥
        æ€§èƒ½ä¼˜åŒ–
        æ–‡æ¡£ç”Ÿæˆ
      æ™ºèƒ½ç‰¹æ€§
        æ„å›¾è¯†åˆ«
        ä¸Šä¸‹æ–‡ç†è§£
        çŸ¥è¯†æ¨ç†
        å­¦ä¹ é€‚åº”
        ä¸ªæ€§åŒ–æœåŠ¡
      ç³»ç»Ÿé›†æˆ
        å¾®ä»£ç†æ³¨å†Œ
        æœåŠ¡å‘ç°
        è´Ÿè½½å‡è¡¡
        æ•…éšœè½¬ç§»
        ç›‘æ§å‘Šè­¦

    è¿è¡Œæ—¶æ‰©å±•
      æ¶æ„æ‰©å±•
        Runtimeæ¥å£
        ç¯å¢ƒé€‚é…å™¨
        èµ„æºç®¡ç†å™¨
        å®‰å…¨æ§åˆ¶å™¨
        ç›‘æ§é›†æˆå™¨
      ç¯å¢ƒæ”¯æŒ
        å®¹å™¨åŒ–ç¯å¢ƒ
        äº‘åŸç”Ÿç¯å¢ƒ
        è¾¹ç¼˜è®¡ç®—ç¯å¢ƒ
        æ··åˆäº‘ç¯å¢ƒ
        æœ¬åœ°ç¯å¢ƒ
      å®‰å…¨æœºåˆ¶
        æ²™ç®±éš”ç¦»
        æƒé™æ§åˆ¶
        èµ„æºé™åˆ¶
        å®¡è®¡æ—¥å¿—
        å¨èƒæ£€æµ‹
      æ€§èƒ½ä¼˜åŒ–
        èµ„æºè°ƒåº¦
        è´Ÿè½½å‡è¡¡
        ç¼“å­˜ç­–ç•¥
        å¹¶å‘æ§åˆ¶
        æ•…éšœæ¢å¤

    æ’ä»¶ç³»ç»Ÿå¼€å‘
      æ’ä»¶æ¶æ„
        æ’ä»¶æ¥å£
        ç”Ÿå‘½å‘¨æœŸç®¡ç†
        ä¾èµ–æ³¨å…¥
        äº‹ä»¶ç³»ç»Ÿ
        é…ç½®ç®¡ç†
      æ’ä»¶ç±»å‹
        åŠŸèƒ½æ’ä»¶
        UIæ’ä»¶
        é›†æˆæ’ä»¶
        å·¥å…·æ’ä»¶
        ä¸»é¢˜æ’ä»¶
      å¼€å‘å·¥å…·
        æ’ä»¶è„šæ‰‹æ¶
        å¼€å‘SDK
        è°ƒè¯•å·¥å…·
        æµ‹è¯•æ¡†æ¶
        æ‰“åŒ…å·¥å…·
      ç”Ÿæ€å»ºè®¾
        æ’ä»¶å¸‚åœº
        ç‰ˆæœ¬ç®¡ç†
        è´¨é‡è®¤è¯
        ç¤¾åŒºæ”¯æŒ
        æ–‡æ¡£ä½“ç³»

    ç³»ç»Ÿé›†æˆä¼˜åŒ–
      æ¶æ„æ•´åˆ
        æ¨¡å—åŒ–è®¾è®¡
        æ¥å£ç»Ÿä¸€
        æ•°æ®æµä¼˜åŒ–
        é”™è¯¯å¤„ç†
        æ€§èƒ½è°ƒä¼˜
      è´¨é‡ä¿è¯
        å•å…ƒæµ‹è¯•
        é›†æˆæµ‹è¯•
        æ€§èƒ½æµ‹è¯•
        å®‰å…¨æµ‹è¯•
        å…¼å®¹æ€§æµ‹è¯•
      éƒ¨ç½²å‡†å¤‡
        ç¯å¢ƒé…ç½®
        ä¾èµ–ç®¡ç†
        æ„å»ºä¼˜åŒ–
        ç›‘æ§é…ç½®
        æ–‡æ¡£å®Œå–„
      æŒç»­æ”¹è¿›
        æ€§èƒ½ç›‘æ§
        ç”¨æˆ·åé¦ˆ
        è¿­ä»£ä¼˜åŒ–
        æŠ€æœ¯å‡çº§
        ç”Ÿæ€æ‰©å±•
```

## ğŸ¯ æ‰©å±•å¼€å‘æŠ€æœ¯è·¯å¾„

### 1. å·¥å…·å¼€å‘æŠ€æœ¯è·¯å¾„
```mermaid
graph TD
    A[å·¥å…·éœ€æ±‚åˆ†æ] --> B[æ¥å£è®¾è®¡]
    B --> C[æ ¸å¿ƒåŠŸèƒ½å®ç°]
    C --> D[é”™è¯¯å¤„ç†]
    D --> E[æ€§èƒ½ä¼˜åŒ–]
    E --> F[æµ‹è¯•éªŒè¯]
    F --> G[æ–‡æ¡£ç¼–å†™]
    G --> H[é›†æˆéƒ¨ç½²]
```

### 2. å¾®ä»£ç†å¼€å‘æŠ€æœ¯è·¯å¾„
```mermaid
graph TD
    A[é¢†åŸŸåˆ†æ] --> B[çŸ¥è¯†å»ºæ¨¡]
    B --> C[è§¦å‘æœºåˆ¶è®¾è®¡]
    C --> D[æ¨ç†å¼•æ“å®ç°]
    D --> E[ä¸Šä¸‹æ–‡ç®¡ç†]
    E --> F[å­¦ä¹ é€‚åº”]
    F --> G[æ€§èƒ½ä¼˜åŒ–]
    G --> H[ç³»ç»Ÿé›†æˆ]
```

### 3. è¿è¡Œæ—¶æ‰©å±•æŠ€æœ¯è·¯å¾„
```mermaid
graph TD
    A[ç¯å¢ƒåˆ†æ] --> B[æ¥å£è®¾è®¡]
    B --> C[é€‚é…å™¨å®ç°]
    C --> D[å®‰å…¨æœºåˆ¶]
    D --> E[èµ„æºç®¡ç†]
    E --> F[ç›‘æ§é›†æˆ]
    F --> G[æ€§èƒ½è°ƒä¼˜]
    G --> H[éƒ¨ç½²æµ‹è¯•]
```

## ğŸ“Š æ‰©å±•å¼€å‘èƒ½åŠ›çŸ©é˜µ

| æŠ€èƒ½é¢†åŸŸ | åŸºç¡€èƒ½åŠ› | è¿›é˜¶èƒ½åŠ› | é«˜çº§èƒ½åŠ› | ä¸“å®¶èƒ½åŠ› |
|---------|----------|----------|----------|----------|
| å·¥å…·å¼€å‘ | ç®€å•å·¥å…· | å¤æ‚å·¥å…· | å·¥å…·æ¡†æ¶ | ç”Ÿæ€å»ºè®¾ |
| å¾®ä»£ç† | åŸºç¡€ä»£ç† | ä¸“ä¸šä»£ç† | æ™ºèƒ½ä»£ç† | è‡ªé€‚åº”ä»£ç† |
| è¿è¡Œæ—¶ | ç¯å¢ƒé€‚é… | å®‰å…¨éš”ç¦» | æ€§èƒ½ä¼˜åŒ– | æ¶æ„è®¾è®¡ |
| æ’ä»¶ç³»ç»Ÿ | æ’ä»¶å¼€å‘ | æ’ä»¶ç®¡ç† | æ’ä»¶ç”Ÿæ€ | å¹³å°æ¶æ„ |

## ğŸ› ï¸ æ ¸å¿ƒå¼€å‘æ¨¡å¼

### 1. å·¥å…·å¼€å‘æ¨¡å¼
```python
# é«˜çº§å·¥å…·å¼€å‘æ¨¡å¼
class AdvancedTool(BaseTool):
    def __init__(self, config: ToolConfig):
        super().__init__(config)
        self.cache = ToolCache()
        self.monitor = ToolMonitor()
        self.validator = ToolValidator()

    async def execute(self, action: Action) -> Observation:
        # é¢„å¤„ç†å’ŒéªŒè¯
        validated_action = await self.validator.validate(action)

        # ç¼“å­˜æ£€æŸ¥
        cached_result = await self.cache.get(validated_action)
        if cached_result:
            return cached_result

        # æ‰§è¡Œå·¥å…·é€»è¾‘
        with self.monitor.track_execution():
            result = await self._execute_core_logic(validated_action)

        # åå¤„ç†å’Œç¼“å­˜
        processed_result = await self._post_process(result)
        await self.cache.set(validated_action, processed_result)

        return processed_result

    async def _execute_core_logic(self, action: Action) -> Any:
        # æ ¸å¿ƒä¸šåŠ¡é€»è¾‘
        pass

    async def _post_process(self, result: Any) -> Observation:
        # ç»“æœåå¤„ç†
        pass
```

### 2. å¾®ä»£ç†å¼€å‘æ¨¡å¼
```python
# æ™ºèƒ½å¾®ä»£ç†å¼€å‘æ¨¡å¼
class IntelligentMicroagent(BaseMicroagent):
    def __init__(self, domain: str):
        super().__init__(domain)
        self.knowledge_base = KnowledgeBase(domain)
        self.context_manager = ContextManager()
        self.reasoning_engine = ReasoningEngine()
        self.learning_module = LearningModule()

    async def process_request(self, request: Request) -> Response:
        # ä¸Šä¸‹æ–‡ç†è§£
        context = await self.context_manager.build_context(request)

        # çŸ¥è¯†æ£€ç´¢
        relevant_knowledge = await self.knowledge_base.retrieve(
            request.query, context
        )

        # æ¨ç†å†³ç­–
        decision = await self.reasoning_engine.reason(
            request, context, relevant_knowledge
        )

        # æ‰§è¡Œå†³ç­–
        response = await self._execute_decision(decision)

        # å­¦ä¹ åé¦ˆ
        await self.learning_module.learn_from_interaction(
            request, response, context
        )

        return response

    async def _execute_decision(self, decision: Decision) -> Response:
        # å†³ç­–æ‰§è¡Œé€»è¾‘
        pass
```

### 3. è¿è¡Œæ—¶æ‰©å±•æ¨¡å¼
```python
# é«˜çº§è¿è¡Œæ—¶æ‰©å±•æ¨¡å¼
class AdvancedRuntime(BaseRuntime):
    def __init__(self, config: RuntimeConfig):
        super().__init__(config)
        self.resource_manager = ResourceManager()
        self.security_controller = SecurityController()
        self.monitor = RuntimeMonitor()
        self.scheduler = TaskScheduler()

    async def execute_action(self, action: Action) -> Observation:
        # å®‰å…¨æ£€æŸ¥
        await self.security_controller.validate_action(action)

        # èµ„æºåˆ†é…
        resources = await self.resource_manager.allocate(action)

        try:
            # ä»»åŠ¡è°ƒåº¦
            task = await self.scheduler.schedule_task(action, resources)

            # ç›‘æ§æ‰§è¡Œ
            with self.monitor.track_execution(task):
                result = await self._execute_in_environment(task)

            return result

        finally:
            # èµ„æºé‡Šæ”¾
            await self.resource_manager.release(resources)

    async def _execute_in_environment(self, task: Task) -> Observation:
        # ç¯å¢ƒç‰¹å®šçš„æ‰§è¡Œé€»è¾‘
        pass
```

## ğŸ” é«˜çº§å¼€å‘æŠ€æœ¯

### 1. å¼‚æ­¥ç¼–ç¨‹æ¨¡å¼
```python
# é«˜çº§å¼‚æ­¥æ¨¡å¼
import asyncio
from typing import AsyncGenerator

class AsyncToolExecutor:
    def __init__(self, max_concurrent: int = 10):
        self.semaphore = asyncio.Semaphore(max_concurrent)
        self.task_queue = asyncio.Queue()
        self.result_cache = {}

    async def execute_batch(self, actions: List[Action]) -> List[Observation]:
        """æ‰¹é‡å¼‚æ­¥æ‰§è¡Œ"""
        tasks = [self._execute_with_semaphore(action) for action in actions]
        results = await asyncio.gather(*tasks, return_exceptions=True)
        return [r if not isinstance(r, Exception) else self._handle_error(r)
                for r in results]

    async def _execute_with_semaphore(self, action: Action) -> Observation:
        async with self.semaphore:
            return await self._execute_action(action)

    async def stream_execute(self, action: Action) -> AsyncGenerator[Observation, None]:
        """æµå¼æ‰§è¡Œ"""
        async for partial_result in self._stream_execution(action):
            yield partial_result
```

### 2. æ’ä»¶ç³»ç»Ÿæ¶æ„
```python
# æ’ä»¶ç³»ç»Ÿæ¶æ„
class PluginManager:
    def __init__(self):
        self.plugins: Dict[str, Plugin] = {}
        self.hooks: Dict[str, List[Callable]] = {}
        self.dependencies: Dict[str, List[str]] = {}

    async def load_plugin(self, plugin_path: str) -> Plugin:
        """åŠ¨æ€åŠ è½½æ’ä»¶"""
        spec = importlib.util.spec_from_file_location("plugin", plugin_path)
        module = importlib.util.module_from_spec(spec)
        spec.loader.exec_module(module)

        plugin = module.create_plugin()
        await self._validate_plugin(plugin)
        await self._resolve_dependencies(plugin)

        self.plugins[plugin.name] = plugin
        await plugin.initialize()

        return plugin

    async def execute_hook(self, hook_name: str, *args, **kwargs):
        """æ‰§è¡Œé’©å­å‡½æ•°"""
        if hook_name in self.hooks:
            for hook_func in self.hooks[hook_name]:
                try:
                    await hook_func(*args, **kwargs)
                except Exception as e:
                    logger.error(f"Hook {hook_name} failed: {e}")

    def register_hook(self, hook_name: str, func: Callable):
        """æ³¨å†Œé’©å­å‡½æ•°"""
        if hook_name not in self.hooks:
            self.hooks[hook_name] = []
        self.hooks[hook_name].append(func)
```

### 3. æ™ºèƒ½ç¼“å­˜ç³»ç»Ÿ
```python
# æ™ºèƒ½ç¼“å­˜ç³»ç»Ÿ
class IntelligentCache:
    def __init__(self):
        self.memory_cache = {}
        self.disk_cache = DiskCache()
        self.distributed_cache = RedisCache()
        self.cache_stats = CacheStats()

    async def get(self, key: str, context: Dict = None) -> Any:
        """æ™ºèƒ½ç¼“å­˜è·å–"""
        # æ£€æŸ¥å†…å­˜ç¼“å­˜
        if key in self.memory_cache:
            self.cache_stats.record_hit('memory')
            return self.memory_cache[key]

        # æ£€æŸ¥ç£ç›˜ç¼“å­˜
        disk_result = await self.disk_cache.get(key)
        if disk_result:
            self.cache_stats.record_hit('disk')
            # æå‡åˆ°å†…å­˜ç¼“å­˜
            self.memory_cache[key] = disk_result
            return disk_result

        # æ£€æŸ¥åˆ†å¸ƒå¼ç¼“å­˜
        distributed_result = await self.distributed_cache.get(key)
        if distributed_result:
            self.cache_stats.record_hit('distributed')
            # æå‡åˆ°æœ¬åœ°ç¼“å­˜
            await self._promote_to_local(key, distributed_result)
            return distributed_result

        self.cache_stats.record_miss()
        return None

    async def set(self, key: str, value: Any, ttl: int = 3600):
        """æ™ºèƒ½ç¼“å­˜è®¾ç½®"""
        # æ ¹æ®æ•°æ®å¤§å°å’Œè®¿é—®æ¨¡å¼é€‰æ‹©ç¼“å­˜å±‚çº§
        cache_strategy = await self._determine_cache_strategy(key, value)

        if cache_strategy.use_memory:
            self.memory_cache[key] = value

        if cache_strategy.use_disk:
            await self.disk_cache.set(key, value, ttl)

        if cache_strategy.use_distributed:
            await self.distributed_cache.set(key, value, ttl)
```

## ğŸ“ˆ æ€§èƒ½ä¼˜åŒ–ç­–ç•¥

### 1. å·¥å…·æ€§èƒ½ä¼˜åŒ–
```python
# å·¥å…·æ€§èƒ½ä¼˜åŒ–
class OptimizedTool(BaseTool):
    def __init__(self):
        super().__init__()
        self.connection_pool = ConnectionPool()
        self.batch_processor = BatchProcessor()
        self.result_cache = LRUCache(maxsize=1000)

    async def execute_optimized(self, actions: List[Action]) -> List[Observation]:
        # æ‰¹å¤„ç†ä¼˜åŒ–
        batched_actions = self.batch_processor.group_actions(actions)

        # å¹¶è¡Œæ‰§è¡Œ
        tasks = []
        for batch in batched_actions:
            task = asyncio.create_task(self._execute_batch(batch))
            tasks.append(task)

        batch_results = await asyncio.gather(*tasks)

        # å±•å¹³ç»“æœ
        return [result for batch_result in batch_results for result in batch_result]

    @lru_cache(maxsize=128)
    def _compute_expensive_operation(self, data: str) -> str:
        # æ˜‚è´µè®¡ç®—çš„ç¼“å­˜ç‰ˆæœ¬
        return expensive_computation(data)
```

### 2. å†…å­˜ç®¡ç†ä¼˜åŒ–
```python
# å†…å­˜ç®¡ç†ä¼˜åŒ–
class MemoryOptimizedComponent:
    def __init__(self):
        self.object_pool = ObjectPool()
        self.weak_references = weakref.WeakValueDictionary()
        self.memory_monitor = MemoryMonitor()

    async def process_large_dataset(self, dataset: Iterator[Any]):
        """å¤„ç†å¤§æ•°æ®é›†çš„å†…å­˜ä¼˜åŒ–ç‰ˆæœ¬"""
        with self.memory_monitor.track_usage():
            async for chunk in self._chunk_dataset(dataset, chunk_size=1000):
                # ä½¿ç”¨å¯¹è±¡æ± å‡å°‘å†…å­˜åˆ†é…
                processor = self.object_pool.get_processor()
                try:
                    result = await processor.process(chunk)
                    yield result
                finally:
                    self.object_pool.return_processor(processor)

                # å®šæœŸæ£€æŸ¥å†…å­˜ä½¿ç”¨
                if self.memory_monitor.usage_high():
                    await self._trigger_gc()

    async def _trigger_gc(self):
        """è§¦å‘åƒåœ¾å›æ”¶"""
        import gc
        gc.collect()
        await asyncio.sleep(0.1)  # è®©å‡ºæ§åˆ¶æƒ
```

## ğŸ”§ è°ƒè¯•å’Œæµ‹è¯•å·¥å…·

### 1. æ‰©å±•ç»„ä»¶æµ‹è¯•æ¡†æ¶
```python
# æ‰©å±•ç»„ä»¶æµ‹è¯•æ¡†æ¶
class ExtensionTestFramework:
    def __init__(self):
        self.test_environment = TestEnvironment()
        self.mock_factory = MockFactory()
        self.assertion_helper = AssertionHelper()

    async def test_tool(self, tool: BaseTool, test_cases: List[TestCase]):
        """æµ‹è¯•å·¥å…·åŠŸèƒ½"""
        results = []

        for test_case in test_cases:
            # è®¾ç½®æµ‹è¯•ç¯å¢ƒ
            await self.test_environment.setup(test_case.environment)

            try:
                # æ‰§è¡Œæµ‹è¯•
                result = await tool.execute(test_case.action)

                # éªŒè¯ç»“æœ
                assertion_result = await self.assertion_helper.verify(
                    result, test_case.expected_result
                )

                results.append(TestResult(
                    test_case=test_case,
                    actual_result=result,
                    assertion_result=assertion_result,
                    success=assertion_result.passed
                ))

            except Exception as e:
                results.append(TestResult(
                    test_case=test_case,
                    error=str(e),
                    success=False
                ))

            finally:
                # æ¸…ç†æµ‹è¯•ç¯å¢ƒ
                await self.test_environment.cleanup()

        return TestReport(results)
```

### 2. æ€§èƒ½åŸºå‡†æµ‹è¯•
```python
# æ€§èƒ½åŸºå‡†æµ‹è¯•
class PerformanceBenchmark:
    def __init__(self):
        self.metrics_collector = MetricsCollector()
        self.load_generator = LoadGenerator()
        self.report_generator = ReportGenerator()

    async def benchmark_tool(self, tool: BaseTool, benchmark_config: BenchmarkConfig):
        """å·¥å…·æ€§èƒ½åŸºå‡†æµ‹è¯•"""
        # é¢„çƒ­
        await self._warmup(tool, benchmark_config.warmup_requests)

        # åŸºå‡†æµ‹è¯•
        with self.metrics_collector.collect():
            await self.load_generator.generate_load(
                tool,
                benchmark_config.load_pattern,
                benchmark_config.duration
            )

        # ç”ŸæˆæŠ¥å‘Š
        metrics = self.metrics_collector.get_metrics()
        report = await self.report_generator.generate_performance_report(
            tool, metrics, benchmark_config
        )

        return report

    async def _warmup(self, tool: BaseTool, warmup_requests: int):
        """é¢„çƒ­å·¥å…·"""
        warmup_actions = [self._create_warmup_action() for _ in range(warmup_requests)]
        await asyncio.gather(*[tool.execute(action) for action in warmup_actions])
```

## ğŸ¯ æ‰©å±•å¼€å‘æœ€ä½³å®è·µ

### 1. è®¾è®¡åŸåˆ™
- **æ¨¡å—åŒ–è®¾è®¡**ï¼šä¿æŒç»„ä»¶çš„ç‹¬ç«‹æ€§å’Œå¯å¤ç”¨æ€§
- **æ¥å£ä¸€è‡´æ€§**ï¼šéµå¾ªç»Ÿä¸€çš„æ¥å£è§„èŒƒå’Œçº¦å®š
- **é”™è¯¯å¤„ç†**ï¼šå®Œå–„çš„é”™è¯¯å¤„ç†å’Œæ¢å¤æœºåˆ¶
- **æ€§èƒ½è€ƒè™‘**ï¼šä»è®¾è®¡é˜¶æ®µå°±è€ƒè™‘æ€§èƒ½å½±å“

### 2. å¼€å‘æµç¨‹
- **éœ€æ±‚åˆ†æ**ï¼šæ·±å…¥ç†è§£ç”¨æˆ·éœ€æ±‚å’Œä½¿ç”¨åœºæ™¯
- **æ¶æ„è®¾è®¡**ï¼šè®¾è®¡å¯æ‰©å±•å’Œå¯ç»´æŠ¤çš„æ¶æ„
- **åŸå‹å¼€å‘**ï¼šå¿«é€Ÿæ„å»ºåŸå‹éªŒè¯è®¾è®¡
- **è¿­ä»£å®Œå–„**ï¼šåŸºäºåé¦ˆæŒç»­æ”¹è¿›

### 3. è´¨é‡ä¿è¯
- **ä»£ç å®¡æŸ¥**ï¼šä¸¥æ ¼çš„ä»£ç å®¡æŸ¥æµç¨‹
- **è‡ªåŠ¨åŒ–æµ‹è¯•**ï¼šå®Œæ•´çš„æµ‹è¯•è¦†ç›–
- **æ€§èƒ½æµ‹è¯•**ï¼šå®šæœŸçš„æ€§èƒ½åŸºå‡†æµ‹è¯•
- **å®‰å…¨å®¡è®¡**ï¼šå®‰å…¨æ¼æ´æ‰«æå’Œä¿®å¤

## ğŸ”— å­¦ä¹ èµ„æºæ¨è

### æŠ€æœ¯æ–‡æ¡£
- [Pythonå¼‚æ­¥ç¼–ç¨‹æŒ‡å—](https://docs.python.org/3/library/asyncio.html)
- [æ’ä»¶æ¶æ„è®¾è®¡æ¨¡å¼](https://martinfowler.com/articles/plugins.html)
- [å¾®æœåŠ¡æ¶æ„æœ€ä½³å®è·µ](https://microservices.io/)

### å¼€æºé¡¹ç›®
- [Pluggy - Pythonæ’ä»¶ç³»ç»Ÿ](https://github.com/pytest-dev/pluggy)
- [Celery - åˆ†å¸ƒå¼ä»»åŠ¡é˜Ÿåˆ—](https://github.com/celery/celery)
- [FastAPI - ç°ä»£Webæ¡†æ¶](https://github.com/tiangolo/fastapi)

### ç¤¾åŒºèµ„æº
- [OpenHandsæ‰©å±•å¼€å‘æŒ‡å—](../../docs/extensions/)
- [å¼€å‘è€…ç¤¾åŒºè®¨è®º](https://github.com/All-Hands-AI/OpenHands/discussions)
- [æŠ€æœ¯åšå®¢å’Œæ¡ˆä¾‹ç ”ç©¶](https://docs.all-hands.dev/blog)
